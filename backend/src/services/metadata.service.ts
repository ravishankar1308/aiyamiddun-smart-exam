import { connection } from \'../index\';\n\ninterface MetadataSchema {\n    grades: any[];\n    subjects: any[];\n    sections: any[];\n    questionTypes: any[];\n    difficulties: any[];\n    roles: any[];\n    questionStatuses: any[];\n}\n\nconst getDefaultMetadata = (): MetadataSchema => ({\n    grades: [{ id: 1, name: \'Grade 12\', isActive: true}],\n    subjects: [{ id: 1, name: \'Physics\', isActive: true}],\n    sections: [{ id: 1, name: \'Section A\', isActive: true}],\n    questionTypes: [{ id: 1, name: \'Multiple Choice\', isActive: true}],\n    difficulties: [],\n    roles: [],\n    questionStatuses: [],\n});\n\nconst readMetadataStore = async (): Promise<Partial<MetadataSchema>> => {\n    try {\n        const [rows] = await connection.query(\'SELECT value FROM metadata WHERE \`key\` = ?\', [\'METADATA_STORE\']);\n        const data = rows as any[];\n        if (data.length > 0 && data[0].value) {\n            const storedData = JSON.parse(data[0].value);\n            return { ...getDefaultMetadata(), ...storedData };\n        }\n        return getDefaultMetadata();\n    } catch (error) {\n        console.error(\"Error reading metadata store, returning default metadata:\", error);\n        return getDefaultMetadata();\n    }\n};\n\n// This function is now more robust and does not depend on a UNIQUE index.\nconst writeMetadataStore = async (data: Partial<MetadataSchema>): Promise<void> => {\n    try {\n        const jsonData = JSON.stringify(data);\n        const key = \'METADATA_STORE\';\n\n        // 1. Check if the key already exists.\n        const [rows] = await connection.query(\'SELECT \`key\` FROM metadata WHERE \`key\` = ?\', [key]);\n        const existing = rows as any[];\n\n        // 2. Perform either an UPDATE or an INSERT.\n        if (existing.length > 0) {\n            await connection.query(\'UPDATE metadata SET \`value\` = ? WHERE \`key\` = ?\', [jsonData, key]);\n        } else {\n            await connection.query(\'INSERT INTO metadata (\`key\`, \`value\`) VALUES (?, ?)\', [key, jsonData]);\n        }\n    } catch (error) {\n        console.error(\"Error writing metadata store:\", error);\n        throw new Error(\'Failed to write metadata to the database.\');\n    }\n};\n\nexport const getAllMetadata = async (): Promise<Partial<MetadataSchema>> => {\n    return await readMetadataStore();\n};\n\nexport const getMetadata = async (key: string): Promise<any> => {\n    const allMetadata = await readMetadataStore();\n    return allMetadata[key];\n};\n\nexport const updateMetadata = async (key: string, value: any): Promise<{ key: string; value: any }> => {\n    const allMetadata = await readMetadataStore();\n    allMetadata[key] = value;\n    await writeMetadataStore(allMetadata);\n    return { key, value };\n};\n